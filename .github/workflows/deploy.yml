name: Deploy to Oracle Cloud

on:
  workflow_dispatch:  # Manual deployment only
  workflow_run:       # Auto-deploy after CI passes
    workflows: ["CI/CD Pipeline"]
    types: [completed]
    branches: [main]

jobs:
  # Check if CI passed
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      should-deploy: ${{ steps.check.outputs.result }}
    steps:
      - name: Check CI conclusion
        id: check
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "result=true" >> $GITHUB_OUTPUT
            echo "âœ… Manual deployment triggered"
          elif [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
            echo "result=true" >> $GITHUB_OUTPUT
            echo "âœ… CI passed, proceeding with deployment"
          else
            echo "result=false" >> $GITHUB_OUTPUT
            echo "âŒ CI did not pass, skipping deployment"
          fi

  # Deploy to Oracle Cloud
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: check-ci
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH key
        env:
          SSH_PRIVATE_KEY: ${{ secrets.OCI_SSH_PRIVATE_KEY }}
          SSH_HOST: ${{ secrets.OCI_HOST }}
          SSH_USER: ${{ secrets.OCI_USER }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts
          echo "âœ… SSH key configured"

      - name: Test SSH connection
        env:
          SSH_HOST: ${{ secrets.OCI_HOST }}
          SSH_USER: ${{ secrets.OCI_USER }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST 'echo "âœ… SSH connection successful"'

      - name: Deploy to Oracle Cloud
        env:
          SSH_HOST: ${{ secrets.OCI_HOST }}
          SSH_USER: ${{ secrets.OCI_USER }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST << 'ENDSSH'
            set -e  # Exit on any error

            echo "ðŸš€ Starting deployment..."

            # Navigate to project directory
            cd ~/ai-portfolio

            # Pull latest code
            echo "ðŸ“¥ Pulling latest code from GitHub..."
            git fetch origin
            git reset --hard origin/main

            # Ensure backups directory exists
            mkdir -p ~/backups

            # Ensure NEXT_PUBLIC_API_BASE_URL is set in .env for production
            if ! grep -q "NEXT_PUBLIC_API_BASE_URL" .env; then
              echo "âž• Adding NEXT_PUBLIC_API_BASE_URL to .env..."
              echo "NEXT_PUBLIC_API_BASE_URL=https://wwwportfolio.henrihaapala.com" >> .env
            fi

            # Backup database before deployment (safety measure)
            echo "ðŸ’¾ Creating database backup..."
            docker-compose exec -T postgres pg_dump -U aiportfolio aiportfolio > ~/backups/pre-deploy-$(date +%Y%m%d-%H%M%S).sql || echo "âš ï¸ Backup failed (non-critical)"

            # Stop and remove old containers first
            echo "ðŸ›‘ Stopping and removing old containers..."
            docker-compose down --remove-orphans

            # Force remove any stuck containers
            echo "ðŸ§¹ Cleaning up stuck containers..."
            docker ps -a | grep aiportfolio | awk '{print $1}' | xargs -r docker rm -f || echo "No stuck containers"

            # Pull latest Docker images
            echo "ðŸ“¦ Pulling Docker images..."
            docker-compose pull

            # Rebuild services (to pick up code changes)
            echo "ðŸ”¨ Rebuilding Docker images..."
            docker-compose build --no-cache

            # Start new containers
            echo "ðŸš€ Starting new containers..."
            docker-compose up -d

            # Wait for postgres
            echo "â³ Waiting for PostgreSQL..."
            sleep 10

            # Install pgvector extension
            echo "ðŸ”§ Installing pgvector extension..."
            docker-compose exec -T postgres psql -U aiportfolio aiportfolio -c "CREATE EXTENSION IF NOT EXISTS vector;"

            # Wait for backend
            echo "â³ Waiting for backend..."
            sleep 10

            # Run database migrations
            echo "ðŸ—ƒï¸ Running database migrations..."
            docker-compose exec -T backend python manage.py migrate --noinput

            # Collect static files (if needed)
            echo "ðŸ“¦ Collecting static files..."
            docker-compose exec -T backend python manage.py collectstatic --noinput || echo "âš ï¸ Static files warning (might be expected)"

            # Verify all services are running
            echo "âœ… Checking service health..."
            docker-compose ps

            # Test backend health
            echo "ðŸ” Testing backend health endpoint..."
            curl -f http://localhost:8000/api/health/ || echo "âš ï¸ Backend health check failed"

            # Test frontend
            echo "ðŸ” Testing frontend..."
            curl -f http://localhost:3000 || echo "âš ï¸ Frontend health check failed"

            # Reload nginx to pick up any config changes
            echo "ðŸ”„ Reloading nginx..."
            sudo nginx -t && sudo systemctl reload nginx

            echo "ðŸŽ‰ Deployment completed successfully!"
            echo "ðŸŒ Site: https://wwwportfolio.henrihaapala.com"

            # Show container status
            echo ""
            echo "ðŸ“Š Container Status:"
            docker-compose ps

          ENDSSH

      - name: Post-deployment verification
        env:
          SITE_URL: https://wwwportfolio.henrihaapala.com
        run: |
          echo "ðŸ” Verifying deployment..."

          # Wait for service with timeout and retries (production-grade health check)
          wait_for_service() {
            local url=$1
            local name=$2
            local timeout=300  # 5 minutes total timeout
            local interval=10  # Check every 10 seconds
            local elapsed=0

            echo "â³ Waiting for $name to become healthy..."

            while [ $elapsed -lt $timeout ]; do
              status=$(curl -f -s -o /dev/null -w "%{http_code}" "$url" 2>/dev/null || echo "000")

              if echo "$status" | grep -q "200\|301\|302"; then
                echo "âœ… $name is healthy (HTTP $status) - took ${elapsed}s"
                return 0
              fi

              echo "   â³ $name not ready yet (HTTP $status) - waiting... (${elapsed}/${timeout}s)"
              sleep $interval
              elapsed=$((elapsed + interval))
            done

            echo "âŒ $name failed to become healthy after ${timeout}s (last status: HTTP $status)"
            return 1
          }

          # Check all services (fail fast if any service fails)
          wait_for_service "$SITE_URL" "Frontend" || exit 1
          wait_for_service "$SITE_URL/api/health/" "Backend API" || exit 1
          wait_for_service "$SITE_URL/agent/health" "Agent Service" || exit 1

          echo ""
          echo "ðŸŽ‰ All services are healthy and responding!"
          echo "ðŸŒ Site: $SITE_URL"

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          echo "ðŸ§¹ SSH key cleaned up"

      - name: Send deployment notification
        if: success()
        run: |
          echo "ðŸš€ Deployment successful!"
          echo "Site: https://wwwportfolio.henrihaapala.com"
          echo "Commit: ${{ github.sha }}"
          echo "Deployed by: ${{ github.actor }}"

      - name: Rollback on failure
        if: failure()
        env:
          SSH_HOST: ${{ secrets.OCI_HOST }}
          SSH_USER: ${{ secrets.OCI_USER }}
        run: |
          echo "âŒ Deployment failed, attempting rollback..."

          # Re-setup SSH key for rollback
          echo "${{ secrets.OCI_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST << 'ENDSSH'
            cd ~/ai-portfolio

            # Restore previous version
            git checkout HEAD~1
            docker-compose down
            docker-compose up -d

            echo "ðŸ”„ Rolled back to previous version"
          ENDSSH

  # Job to notify on deployment status
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "âœ… Deployment succeeded!"
            echo "ðŸŒ Site: https://wwwportfolio.henrihaapala.com"
          else
            echo "âŒ Deployment failed!"
            echo "Check logs for details"
            exit 1
          fi
